# -*- coding: utf-8 -*-
"""Vizualise_Sentiments.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ftKxfs_oZZEGXhjjzZ4a5YGNg2WwqZWT
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

# Basis-Pfad zu deinem Projekt-Ordner in Google Drive
BASE_DIR = '/content/drive/MyDrive/ML | Final Team Project'
VADER_DIR = '/content/drive/MyDrive/ML | Final Team Project/VADER/labeled_vader'
BERT_DIR = '/content/drive/MyDrive/ML | Final Team Project/BERT/Labeled_data'

# What movies? ( [5] or [2,5,7] or list(range(1,11)))
selected_BERT = list(range(1,11))
selected_VADER  = list(range(1,11))


# Pattern („{movie}_all_labeled.csv“)
BERT_pat = os.path.join(BERT_DIR, '{movie}_all_labeled.csv')
vader_pat  = os.path.join(VADER_DIR,  '{movie}_labeled_vader.xlsx')

date_col = "comment_time"
BERT_sent_col = 'predicted_sentiment'
vader_sent_col  = 'vader_sentiment'

sentiment_map = {"negative": 0, "neutral": 1, "positive": 2}

movie_names = {
    1: "Pirates 1 – Curse of the Black Pearl",
    2: "Pirates 2 – Dead Man's Chest",
    3: "Pirates 3 – At World's End",
    4: "Pirates 4 – On Stranger Tides",
    5: "Pirates 5 – Dead Men Tell No Tales",
    6: "Twilight 1",
    7: "Twilight – New Moon",
    8: "Twilight – Eclipse",
    9: "Twilight – Breaking Dawn 1",
    10:"Twilight – Breaking Dawn 2"
}

# Definition of both movie series
series1 = list(range(1,6))   # Filme 1–5
series2 = list(range(6,11))  # Filme 6–10

records = []

# Dataframe for BERT
for m in selected_BERT:
    df = pd.read_csv(BERT_pat.format(movie=m), parse_dates=[date_col])
    df = df.dropna(subset=[date_col, BERT_sent_col])
    df = df[[date_col, BERT_sent_col]].copy()
    df['sent_num'] = df[BERT_sent_col].map(sentiment_map)
    df['movie'] = m
    df['model'] = 'BERT'
    records.append(df[[date_col, 'movie', 'model', 'sent_num']])

# VADER data (Excel)
for m in selected_VADER:
    df = pd.read_excel(vader_pat.format(movie=m), engine='openpyxl', parse_dates=[date_col])
    df = df.dropna(subset=[date_col, vader_sent_col])
    df = df[[date_col, vader_sent_col]].copy()
    df['sent_num'] = df[vader_sent_col].map(sentiment_map)
    df['movie'] = m
    df['model'] = 'VADER'
    records.append(df[[date_col, 'movie', 'model', 'sent_num']])

    # Combine into one DataFrame
full_df = pd.concat(records, ignore_index=True)

# prompt: get the mean BERT sentiments for each movie

# Filter for BERT data
bert_df = full_df[full_df['model'] == 'BERT']

# Group by movie and calculate the mean sentiment
mean_bert_sentiments = bert_df.groupby('movie')['sent_num'].mean()

# Print the mean sentiments
print("Mean BERT Sentiments for each movie:")
mean_bert_sentiments

import matplotlib.font_manager as fm
fm.fontManager.addfont('/content/drive/MyDrive/ML | Final Team Project/times.ttf')

# set color settings
style_map = {
    'BERT': {'linestyle':'-',  'color':'tab:blue'},
    'VADER':  {'linestyle':'--', 'color':'tab:orange'}
}
linestyles = ['-', '--', ':', '-.', '-'] # Define a list of linestyles

plt.rcParams['font.family'] = 'Times New Roman'

for model in ['BERT','VADER']:
    subset = full_df[full_df['model']==model]
    movie_list = selected_BERT if model=='Custom' else selected_VADER
    for i, m in enumerate(movie_list): # Use enumerate to get the index
        ts = subset[subset['movie']==m].set_index(date_col)['sent_num']\
                 .resample('YE').mean().interpolate()
        plt.plot(
            ts.index, ts.values,
            linestyle=linestyles[i % len(linestyles)], # Cycle through linestyles
            color=style_map[model]['color'],
            label=f"{model} – {movie_names[m]}"
        )

plt.xlabel('Date')
plt.ylabel('Mean Sentiment')
plt.title('Sentiment over Time: Custom Model vs. VADER')
plt.legend(ncol=2, fontsize='small')
plt.tight_layout()
plt.show()

#Series Comparison - Mean Sentiment
summary = {}
for model in ['BERT','VADER']:
    dfm = full_df[full_df['model']==model]
    m1 = dfm[dfm['movie'].isin(series1)]['sent_num'].mean()
    m2 = dfm[dfm['movie'].isin(series2)]['sent_num'].mean()
    summary[model] = (m1, m2)

labels = ['Pirates (1–5)', 'Twilight (6–10)']
x = np.arange(len(labels))
width = 0.35

fig, ax = plt.subplots(figsize=(6,4))
for i, model in enumerate(['BERT','VADER']):
    means = summary[model]
    ax.bar(x + i*width, means, width, label=model)
ax.set_xticks(x + width/2)
ax.set_xticklabels(labels)
ax.set_ylabel('Overall Mean Sentiment')
ax.set_title('Series Mean: Custom vs VADER')
ax.legend()
plt.tight_layout()
plt.show()

# Enter global box office gross (in USD) for each film
box_office = {
    1: 654.264015,
    2: 1066.179725,
    3: 960.996492,
    4: 1045.713802,
    5: 794.881442,
    6: 407.187715,
    7: 709.711008,
    8: 698.491347,
    9: 712.205856,
    10: 829.74682
}

import numpy as np # Import numpy for linear regression

# Calculate mean sentiment for each movie using only BERT data
mean_sentiment_bert = full_df[full_df['model'] == 'BERT'].groupby('movie')['sent_num'].mean()

# Prepare data for plotting (for all movies with BERT data)
movies_for_regression = mean_sentiment_bert.index
box_office_values_for_regression = [box_office[movie] for movie in movies_for_regression]
sentiment_values_for_regression = mean_sentiment_bert.values

# Perform linear regression
# Fit a first-degree polynomial (a line) to the data
slope, intercept = np.polyfit(box_office_values_for_regression, sentiment_values_for_regression, 1)
# Create a function for the line
linear_regression_line = np.poly1d([slope, intercept])

# Prepare data for plotting the line
# Create a range of x values from the minimum to maximum box office values
x_line = np.array([min(box_office_values_for_regression), max(box_office_values_for_regression)])
# Calculate the corresponding y values using the linear regression function
y_line = linear_regression_line(x_line)


# Distinguish between the two series (Pirates and Twilight) - This part remains the same
series1_movies = [m for m in movies_for_regression if m in series1]
series2_movies = [m for m in movies_for_regression if m in series2]

series1_box_office = [box_office[m] for m in series1_movies]
series1_sentiment = [mean_sentiment_bert.loc[m] for m in series1_movies]

series2_box_office = [box_office[m] for m in series2_movies]
series2_sentiment = [mean_sentiment_bert.loc[m] for m in series2_movies]


# Create the plot
plt.figure(figsize=(10, 6))

# Plot Series 1 (Pirates)
plt.scatter(series1_box_office, series1_sentiment, label='Pirates Series (BERT)', color='tab:blue', marker='o')
for i, movie_id in enumerate(series1_movies):
    plt.text(series1_box_office[i], series1_sentiment[i], movie_names[movie_id], fontsize=9)

# Plot Series 2 (Twilight)
plt.scatter(series2_box_office, series2_sentiment, label='Twilight Series (BERT)', color='tab:orange', marker='x')
for i, movie_id in enumerate(series2_movies):
    plt.text(series2_box_office[i], series2_sentiment[i], movie_names[movie_id], fontsize=9)

# Plot the linear regression line
plt.plot(x_line, y_line, color='red', linestyle='--', label=f'Linear Regression (BERT Data) \n y = {slope:.2e}x + {intercept:.2f}')


plt.xlabel('Global Box Office Gross [Mio USD]')
plt.ylabel('Mean Sentiment (BERT)')
plt.title('Box Office [Mio. USD] vs. Mean Sentiment for Movies (BERT Model)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# add budget in Mio USD
budget = {
    1: 140,
    2: 225,
    3: 300,
    4: 378.5,
    5: 275,
    6: 37,
    7: 50,
    8: 68,
    9: 127,
    10: 136
}

# Calculate mean sentiment for each movie using only BERT data
mean_sentiment_bert = full_df[full_df['model'] == 'BERT'].groupby('movie')['sent_num'].mean()

# Prepare data for plotting
movies = mean_sentiment_bert.index
budget_values = [budget[movie] for movie in movies]
sentiment_values = mean_sentiment_bert.values

# Distinguish between the two series (Pirates and Twilight)
series1_movies = [m for m in movies if m in series1]
series2_movies = [m for m in movies if m in series2]

series1_budget = [budget[m] for m in series1_movies]
series1_sentiment = [mean_sentiment_bert.loc[m] for m in series1_movies]

series2_budget = [budget[m] for m in series2_movies]
series2_sentiment = [mean_sentiment_bert.loc[m] for m in series2_movies]


# Create the plot
plt.figure(figsize=(10, 6))

# Plot Series 1 (Pirates)
plt.scatter(series1_budget, series1_sentiment, label='Pirates Series (BERT)', color='tab:blue', marker='o')
for i, movie_id in enumerate(series1_movies):
    plt.text(series1_budget[i], series1_sentiment[i], movie_names[movie_id], fontsize=9)

# Plot Series 2 (Twilight)
plt.scatter(series2_budget, series2_sentiment, label='Twilight Series (BERT)', color='tab:orange', marker='x')
for i, movie_id in enumerate(series2_movies):
    plt.text(series2_budget[i], series2_sentiment[i], movie_names[movie_id], fontsize=9)


plt.xlabel('Budget [Mio USD]')
plt.ylabel('Mean Sentiment (BERT)')
plt.title('Budget [Mio. USD] vs. Mean Sentiment for Movies (BERT Model)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# load ratings
movie_ratings = {
    1:  80,  # Pirates of the Caribbean: The Curse of the Black Pearl
    2:  53,  # Pirates of the Caribbean: Dead Man's Chest
    3:  44,  # Pirates of the Caribbean: At World's End
    4:  33,  # Pirates of the Caribbean: On Stranger Tides
    5:  30,  # Pirates of the Caribbean: Dead Men Tell No Tales
    6:  49,  # Twilight
    7:  28,  # The Twilight Saga: New Moon
    8:  46,  # The Twilight Saga: Eclipse
    9:  25,  # The Twilight Saga: Breaking Dawn Part 1
    10: 49   # The Twilight Saga: Breaking Dawn Part 2
}

audience_ratings = {
    1:  86,
    2:  72,
    3:  72,
    4:  54,
    5:  60,
    6:  72,
    7:  61,
    8:  60,
    9:  60,
    10: 70
}

critic_scaled = {
    1:  80  * 0.02,  # 1.60
    2:  53  * 0.02,  # 1.06
    3:  44  * 0.02,  # 0.88
    4:  33  * 0.02,  # 0.66
    5:  30  * 0.02,  # 0.60
    6:  49  * 0.02,  # 0.98
    7:  28  * 0.02,  # 0.56
    8:  46  * 0.02,  # 0.92
    9:  25  * 0.02,  # 0.50
    10: 49  * 0.02   # 0.98
}

audience_scaled = {
    1:  86  * 0.02,  # 1.72
    2:  72  * 0.02,  # 1.44
    3:  72  * 0.02,  # 1.44
    4:  54  * 0.02,  # 1.08
    5:  60  * 0.02,  # 1.20
    6:  72  * 0.02,  # 1.44
    7:  61  * 0.02,  # 1.22
    8:  60  * 0.02,  # 1.20
    9:  60  * 0.02,  # 1.20
    10: 70  * 0.02   # 1.40
}

# Calculate mean sentiment for each movie using only BERT data
mean_sentiment_bert = full_df[full_df['model'] == 'BERT'].groupby('movie')['sent_num'].mean()

# Prepare data for plotting
movies_with_bert = mean_sentiment_bert.index
critic_scaled_values = [critic_scaled[movie] for movie in movies_with_bert]
bert_sentiment_values = [mean_sentiment_bert.loc[movie] for movie in movies_with_bert]

# Distinguish between the two series (Pirates and Twilight)
series1_movies_with_bert = [m for m in movies_with_bert if m in series1]
series2_movies_with_bert = [m for m in movies_with_bert if m in series2]

series1_critic_scaled = [critic_scaled[m] for m in series1_movies_with_bert]
series1_bert_sentiment = [mean_sentiment_bert.loc[m] for m in series1_movies_with_bert]

series2_critic_scaled = [critic_scaled[m] for m in series2_movies_with_bert]
series2_bert_sentiment = [mean_sentiment_bert.loc[m] for m in series2_movies_with_bert]

# Create the plot
plt.figure(figsize=(8, 8))

# Plot Series 1 (Pirates)
plt.scatter(series1_critic_scaled, series1_bert_sentiment, label='Pirates Series (BERT)', color='tab:blue', marker='o')
for i, movie_id in enumerate(series1_movies_with_bert):
    plt.text(series1_critic_scaled[i], series1_bert_sentiment[i], movie_names[movie_id], fontsize=9)

# Plot Series 2 (Twilight)
plt.scatter(series2_critic_scaled, series2_bert_sentiment, label='Twilight Series (BERT)', color='tab:orange', marker='x')
for i, movie_id in enumerate(series2_movies_with_bert):
    plt.text(series2_critic_scaled[i], series2_bert_sentiment[i], movie_names[movie_id], fontsize=9)

# Set equal axis limits
# Find the global min and max across both axes and data series
min_val = min(min(critic_scaled_values), min(bert_sentiment_values))
max_val = max(max(critic_scaled_values), max(bert_sentiment_values))

# Add some padding to the limits
padding = (max_val - min_val) * 0.1
ax_min = min_val - padding
ax_max = max_val + padding

plt.xlim([ax_min, ax_max])
plt.ylim([ax_min, ax_max])
plt.gca().set_aspect('equal', adjustable='box') # Ensure equal aspect ratio

# Add diagonal line (y=x)
plt.plot([ax_min, ax_max], [ax_min, ax_max], color='gray', linestyle='--', label='Diagonal Line (y=x)')


plt.xlabel('Critic Scaled Rating')
plt.ylabel('Mean Sentiment (BERT)')
plt.title('Critic Scaled Rating vs. Mean Sentiment for Movies (BERT Model)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Prepare data for plotting with Audience Scaled Rating
audience_scaled_values = [audience_scaled[movie] for movie in movies_with_bert]

# Distinguish between the two series (Pirates and Twilight) for Audience Scaled
series1_audience_scaled = [audience_scaled[m] for m in series1_movies_with_bert]
series2_audience_scaled = [audience_scaled[m] for m in series2_movies_with_bert]


# Create the plot for Audience Scaled Rating
plt.figure(figsize=(8, 8))

# Plot Series 1 (Pirates)
plt.scatter(series1_audience_scaled, series1_bert_sentiment, label='Pirates Series (BERT)', color='tab:blue', marker='o')
for i, movie_id in enumerate(series1_movies_with_bert):
    plt.text(series1_audience_scaled[i], series1_bert_sentiment[i], movie_names[movie_id], fontsize=9)

# Plot Series 2 (Twilight)
plt.scatter(series2_audience_scaled, series2_bert_sentiment, label='Twilight Series (BERT)', color='tab:orange', marker='x')
for i, movie_id in enumerate(series2_movies_with_bert):
    plt.text(series2_audience_scaled[i], series2_bert_sentiment[i], movie_names[movie_id], fontsize=9)

# Set equal axis limits
# Find the global min and max across both axes and data series
min_val_audience = min(min(audience_scaled_values), min(bert_sentiment_values))
max_val_audience = max(max(audience_scaled_values), max(bert_sentiment_values))

# Add some padding to the limits
padding_audience = (max_val_audience - min_val_audience) * 0.1
ax_min_audience = min_val_audience - padding_audience
ax_max_audience = max_val_audience + padding_audience

plt.xlim([ax_min_audience, ax_max_audience])
plt.ylim([ax_min_audience, ax_max_audience])
plt.gca().set_aspect('equal', adjustable='box') # Ensure equal aspect ratio

# Add diagonal line (y=x)
plt.plot([ax_min_audience, ax_max_audience], [ax_min_audience, ax_max_audience], color='gray', linestyle='--', label='Diagonal Line (y=x)')


plt.xlabel('Audience Scaled Rating')
plt.ylabel('Mean Sentiment (BERT)')
plt.title('Audience Scaled Rating vs. Mean Sentiment for Movies (BERT Model)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

mean_sentiment_vader = full_df[full_df['model'] == 'VADER'].groupby('movie')['sent_num'].mean()

# Prepare data for plotting with VADER sentiment
movies_with_vader = mean_sentiment_vader.index
critic_scaled_values_vader = [critic_scaled[movie] for movie in movies_with_vader]
vader_sentiment_values = [mean_sentiment_vader.loc[movie] for movie in movies_with_vader]

# Distinguish between the two series (Pirates and Twilight) for VADER
series1_movies_with_vader = [m for m in movies_with_vader if m in series1]
series2_movies_with_vader = [m for m in movies_with_vader if m in series2]

series1_critic_scaled_vader = [critic_scaled[m] for m in series1_movies_with_vader]
series1_vader_sentiment = [mean_sentiment_vader.loc[m] for m in series1_movies_with_vader]

series2_critic_scaled_vader = [critic_scaled[m] for m in series2_movies_with_vader]
series2_vader_sentiment = [mean_sentiment_vader.loc[m] for m in series2_movies_with_vader]


# Create the plot for VADER vs Critic Scaled Rating
plt.figure(figsize=(8, 8))

# Plot Series 1 (Pirates)
plt.scatter(series1_critic_scaled_vader, series1_vader_sentiment, label='Pirates Series (VADER)', color='tab:blue', marker='o')
for i, movie_id in enumerate(series1_movies_with_vader):
    plt.text(series1_critic_scaled_vader[i], series1_vader_sentiment[i], movie_names[movie_id], fontsize=9)

# Plot Series 2 (Twilight)
plt.scatter(series2_critic_scaled_vader, series2_vader_sentiment, label='Twilight Series (VADER)', color='tab:orange', marker='x')
for i, movie_id in enumerate(series2_movies_with_vader):
    plt.text(series2_critic_scaled_vader[i], series2_vader_sentiment[i], movie_names[movie_id], fontsize=9)

# Set equal axis limits
min_val_vader_critic = min(min(critic_scaled_values_vader), min(vader_sentiment_values))
max_val_vader_critic = max(max(critic_scaled_values_vader), max(vader_sentiment_values))

padding_vader_critic = (max_val_vader_critic - min_val_vader_critic) * 0.1
ax_min_vader_critic = min_val_vader_critic - padding_vader_critic
ax_max_vader_critic = max_val_vader_critic + padding_vader_critic

plt.xlim([ax_min_vader_critic, ax_max_vader_critic])
plt.ylim([ax_min_vader_critic, ax_max_vader_critic])
plt.gca().set_aspect('equal', adjustable='box')

# Add diagonal line (y=x)
plt.plot([ax_min_vader_critic, ax_max_vader_critic], [ax_min_vader_critic, ax_max_vader_critic], color='gray', linestyle='--', label='Diagonal Line (y=x)')


plt.xlabel('Critic Scaled Rating')
plt.ylabel('Mean Sentiment (VADER)')
plt.title('Critic Scaled Rating vs. Mean Sentiment for Movies (VADER Model)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


# Prepare data for plotting with Audience Scaled Rating for VADER
audience_scaled_values_vader = [audience_scaled[movie] for movie in movies_with_vader]


# Create the plot for VADER vs Audience Scaled Rating
plt.figure(figsize=(8, 8))

# Plot Series 1 (Pirates)
plt.scatter(series1_audience_scaled, series1_vader_sentiment, label='Pirates Series (VADER)', color='tab:blue', marker='o')
for i, movie_id in enumerate(series1_movies_with_vader):
    plt.text(series1_audience_scaled[i], series1_vader_sentiment[i], movie_names[movie_id], fontsize=9)

# Plot Series 2 (Twilight)
plt.scatter(series2_audience_scaled, series2_vader_sentiment, label='Twilight Series (VADER)', color='tab:orange', marker='x')
for i, movie_id in enumerate(series2_movies_with_vader):
    plt.text(series2_audience_scaled[i], series2_vader_sentiment[i], movie_names[movie_id], fontsize=9)

# Set equal axis limits
min_val_vader_audience = min(min(audience_scaled_values_vader), min(vader_sentiment_values))
max_val_vader_audience = max(max(audience_scaled_values_vader), max(vader_sentiment_values))

padding_vader_audience = (max_val_vader_audience - min_val_vader_audience) * 0.1
ax_min_vader_audience = min_val_vader_audience - padding_vader_audience
ax_max_vader_audience = max_val_vader_audience + padding_vader_audience

plt.xlim([ax_min_vader_audience, ax_max_vader_audience])
plt.ylim([ax_min_vader_audience, ax_max_vader_audience])
plt.gca().set_aspect('equal', adjustable='box') # Ensure equal aspect ratio

# Add diagonal line (y=x)
plt.plot([ax_min_vader_audience, ax_max_vader_audience], [ax_min_vader_audience, ax_max_vader_audience], color='gray', linestyle='--', label='Diagonal Line (y=x)')


plt.xlabel('Audience Scaled Rating')
plt.ylabel('Mean Sentiment (VADER)')
plt.title('Audience Scaled Rating vs. Mean Sentiment for Movies (VADER Model)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# prompt: I want to plot word clouds from the labelled data. one for positive, one for neutral and one for negative. Use the comment_body collum to do them. exclude common words and the names of the main charakters of the movies. differentiate between the two series. Get that info from the movie_names and series

import pandas as pd
import matplotlib.pyplot as plt
#!pip install wordcloud nltk matplotlib pandas openpyxl
import nltk
from nltk.corpus import stopwords
from wordcloud import WordCloud
import re

# Download stopwords if not already downloaded
try:
    nltk.data.find('corpora/stopwords')
except nltk.downloader.DownloadError:
    nltk.download('stopwords')
except LookupError:
    nltk.download('stopwords')

# Define characters for each series to exclude
pirates_chars = ['one','first','jack', 'sparrow', 'will', 'turner', 'elizabeth', 'swann', 'barbossa', 'davy', 'jones', 'gibbs', 'movie', 'film', 'scene', 'story', 'plot', 'character', 'actor', 'actress',
    'movies', 'films', 'scenes', 'stories', 'plots', 'characters', 'actors', 'actresses',
    'like', 'really', 'just', 'don', 't', 've', 'll', 're', 'm', 's', 'd', 'didn', 'doesn',
    'isn', 'aren', 'wasn', 'weren', 'haven', 'hasn', 'hadn', 'won', 'wouldn', 'can',
    'good', 'great', 'bad', 'worst', 'best', 'love', 'hate', 'think', 'know', 'people',
    'time', 'way', 'watch', 'watched', 'watching', 'see', 'saw', 'going', 'come', 'came', 'dont', 'im']
twilight_chars = ['book','bella', 'edward', 'jacob', 'cullen', 'swan', 'black', 'volturi', 'alice', 'carlisle', 'esme', 'rosalie', 'emmett', 'jasper', 'movie', 'film', 'scene', 'story', 'plot', 'character', 'actor', 'actress',
    'movies', 'films', 'scenes', 'stories', 'plots', 'characters', 'actors', 'actresses',
    'like', 'really', 'just', 'don', 't', 've', 'll', 're', 'm', 's', 'd', 'didn', 'doesn',
    'isn', 'aren', 'wasn', 'weren', 'haven', 'hasn', 'hadn', 'won', 'wouldn', 'can',
    'good', 'great', 'bad', 'worst', 'best', 'love', 'hate', 'think', 'know', 'people',
    'time', 'way', 'watch', 'watched', 'watching', 'see', 'saw', 'going', 'come', 'came', 'dont', 'im']
common_words = set(stopwords.words('english'))


# Combine common words and character names
all_stop_words = common_words.union(set(pirates_chars)).union(set(twilight_chars))

# Load the datasets again, including the 'comment_body' column
# For BERT
records_wc = []
for m in selected_BERT:
    df = pd.read_csv(BERT_pat.format(movie=m), parse_dates=[date_col])
    df = df.dropna(subset=[date_col, BERT_sent_col, 'comment_body'])
    df = df[[date_col, BERT_sent_col, 'comment_body']].copy()
    df['sent_num'] = df[BERT_sent_col].map(sentiment_map)
    df['movie'] = m
    df['model'] = 'BERT'
    records_wc.append(df[[date_col, 'movie', 'model', 'sent_num', 'comment_body']])

# For VADER (Excel)
for m in selected_VADER:
    df = pd.read_excel(vader_pat.format(movie=m), engine='openpyxl', parse_dates=[date_col])
    df = df.dropna(subset=[date_col, vader_sent_col, 'comment_body'])
    df = df[[date_col, vader_sent_col, 'comment_body']].copy()
    df['sent_num'] = df[vader_sent_col].map(sentiment_map)
    df['movie'] = m
    df['model'] = 'VADER'
    records_wc.append(df[[date_col, 'movie', 'model', 'sent_num', 'comment_body']])

full_df_wc = pd.concat(records_wc, ignore_index=True)

# Function to clean text
def clean_text(text):
    # Add a check to ensure the input is a string
    if not isinstance(text, str):
        return "" # Return an empty string for non-string types
    text = text.lower() # Convert to lowercase
    text = re.sub(r'[^a-z\s]', '', text) # Remove non-alphabetic characters
    words = text.split()
    # Filter out stop words and character names
    words = [word for word in words if word not in all_stop_words and len(word) > 1]
    return ' '.join(words)

# Apply text cleaning
# Ensure the 'comment_body' column is of string type before applying the function
full_df_wc['comment_body'] = full_df_wc['comment_body'].astype(str)
full_df_wc['cleaned_comment_body'] = full_df_wc['comment_body'].apply(clean_text)

# Function to generate and plot word clouds
def plot_wordcloud(text, title):
    wordcloud = WordCloud(width = 800, height = 800,
                background_color ='white',
                stopwords = None, # Stopwords are already removed in cleaning
                min_font_size = 10).generate(text)

    plt.figure(figsize = (8, 8), facecolor = None)
    plt.imshow(wordcloud)
    plt.axis("off")
    plt.tight_layout(pad = 0)
    plt.title(title, fontsize=16)
    plt.show()

# Generate word clouds for each sentiment and series

# Pirates Series Word Clouds (BERT model data used here for example, you can adjust)
pirates_df = full_df_wc[(full_df_wc['movie'].isin(series1)) & (full_df_wc['model'] == 'BERT')]

positive_text_pirates = ' '.join(pirates_df[pirates_df['sent_num'] == 2]['cleaned_comment_body'])
neutral_text_pirates = ' '.join(pirates_df[pirates_df['sent_num'] == 1]['cleaned_comment_body'])
negative_text_pirates = ' '.join(pirates_df[pirates_df['sent_num'] == 0]['cleaned_comment_body'])

if positive_text_pirates:
    plot_wordcloud(positive_text_pirates, 'Word Cloud: Pirates Series - Positive Sentiment (BERT)')
if neutral_text_pirates:
    plot_wordcloud(neutral_text_pirates, 'Word Cloud: Pirates Series - Neutral Sentiment (BERT)')
if negative_text_pirates:
    plot_wordcloud(negative_text_pirates, 'Word Cloud: Pirates Series - Negative Sentiment (BERT)')


# Twilight Series Word Clouds (BERT model data used here for example, you can adjust)
twilight_df = full_df_wc[(full_df_wc['movie'].isin(series2)) & (full_df_wc['model'] == 'BERT')]

positive_text_twilight = ' '.join(twilight_df[twilight_df['sent_num'] == 2]['cleaned_comment_body'])
neutral_text_twilight = ' '.join(twilight_df[twilight_df['sent_num'] == 1]['cleaned_comment_body'])
negative_text_twilight = ' '.join(twilight_df[twilight_df['sent_num'] == 0]['cleaned_comment_body'])

if positive_text_twilight:
    plot_wordcloud(positive_text_twilight, 'Word Cloud: Twilight Series - Positive Sentiment (BERT)')
if neutral_text_twilight:
    plot_wordcloud(neutral_text_twilight, 'Word Cloud: Twilight Series - Neutral Sentiment (BERT)')
if negative_text_twilight:
    plot_wordcloud(negative_text_twilight, 'Word Cloud: Twilight Series - Negative Sentiment (BERT)')

# You can repeat the above for the 'VADER' model by changing the filter:
# pirates_df_vader = full_df_wc[(full_df_wc['movie'].isin(series1)) & (full_df_wc['model'] == 'VADER')]
# twilight_df_vader = full_df_wc[(full_df_wc['movie'].isin(series2)) & (full_df_wc['model'] == 'VADER')]
# ... and generate word clouds similarly, adjusting titles.